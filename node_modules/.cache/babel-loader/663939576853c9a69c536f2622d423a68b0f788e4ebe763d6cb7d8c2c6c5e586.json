{"ast":null,"code":"const conversions = require('./conversions');\n\n/*\n\tThis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n  const graph = {};\n  // https://jsperf.com/object-keys-vs-for-in-with-closure/3\n  const models = Object.keys(conversions);\n  for (let len = models.length, i = 0; i < len; i++) {\n    graph[models[i]] = {\n      // http://jsperf.com/1-vs-infinity\n      // micro-opt, but this is simple.\n      distance: -1,\n      parent: null\n    };\n  }\n  return graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n  const graph = buildGraph();\n  const queue = [fromModel]; // Unshift -> queue -> pop\n\n  graph[fromModel].distance = 0;\n  while (queue.length) {\n    const current = queue.pop();\n    const adjacents = Object.keys(conversions[current]);\n    for (let len = adjacents.length, i = 0; i < len; i++) {\n      const adjacent = adjacents[i];\n      const node = graph[adjacent];\n      if (node.distance === -1) {\n        node.distance = graph[current].distance + 1;\n        node.parent = current;\n        queue.unshift(adjacent);\n      }\n    }\n  }\n  return graph;\n}\nfunction link(from, to) {\n  return function (args) {\n    return to(from(args));\n  };\n}\nfunction wrapConversion(toModel, graph) {\n  const path = [graph[toModel].parent, toModel];\n  let fn = conversions[graph[toModel].parent][toModel];\n  let cur = graph[toModel].parent;\n  while (graph[cur].parent) {\n    path.unshift(graph[cur].parent);\n    fn = link(conversions[graph[cur].parent][cur], fn);\n    cur = graph[cur].parent;\n  }\n  fn.conversion = path;\n  return fn;\n}\nmodule.exports = function (fromModel) {\n  const graph = deriveBFS(fromModel);\n  const conversion = {};\n  const models = Object.keys(graph);\n  for (let len = models.length, i = 0; i < len; i++) {\n    const toModel = models[i];\n    const node = graph[toModel];\n    if (node.parent === null) {\n      // No possible conversion, or this node is the source model.\n      continue;\n    }\n    conversion[toModel] = wrapConversion(toModel, graph);\n  }\n  return conversion;\n};","map":{"version":3,"names":["conversions","require","buildGraph","graph","models","Object","keys","len","length","i","distance","parent","deriveBFS","fromModel","queue","current","pop","adjacents","adjacent","node","unshift","link","from","to","args","wrapConversion","toModel","path","fn","cur","conversion","module","exports"],"sources":["C:/Users/tung0/OneDrive/Documents/typing-speed-app/node_modules/@testing-library/jest-dom/node_modules/color-convert/route.js"],"sourcesContent":["const conversions = require('./conversions');\n\n/*\n\tThis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tconst graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tconst models = Object.keys(conversions);\n\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tconst graph = buildGraph();\n\tconst queue = [fromModel]; // Unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tconst current = queue.pop();\n\t\tconst adjacents = Object.keys(conversions[current]);\n\n\t\tfor (let len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tconst adjacent = adjacents[i];\n\t\t\tconst node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tconst path = [graph[toModel].parent, toModel];\n\tlet fn = conversions[graph[toModel].parent][toModel];\n\n\tlet cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tconst graph = deriveBFS(fromModel);\n\tconst conversion = {};\n\n\tconst models = Object.keys(graph);\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tconst toModel = models[i];\n\t\tconst node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// No possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}