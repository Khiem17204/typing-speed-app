{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bind/callBound');\nvar inspect = require('object-inspect');\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\nvar $Map = GetIntrinsic('%Map%', true);\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\nvar $mapGet = callBound('Map.prototype.get', true);\nvar $mapSet = callBound('Map.prototype.set', true);\nvar $mapHas = callBound('Map.prototype.has', true);\n\n/*\r\n * This function traverses the list returning the node corresponding to the\r\n * given key.\r\n *\r\n * That node is also moved to the head of the list, so that if it's accessed\r\n * again we don't need to traverse the whole list. By doing so, all the recently\r\n * used nodes can be accessed relatively quickly.\r\n */\nvar listGetNode = function (list, key) {\n  // eslint-disable-line consistent-return\n  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {\n    if (curr.key === key) {\n      prev.next = curr.next;\n      curr.next = list.next;\n      list.next = curr; // eslint-disable-line no-param-reassign\n      return curr;\n    }\n  }\n};\nvar listGet = function (objects, key) {\n  var node = listGetNode(objects, key);\n  return node && node.value;\n};\nvar listSet = function (objects, key, value) {\n  var node = listGetNode(objects, key);\n  if (node) {\n    node.value = value;\n  } else {\n    // Prepend the new node to the beginning of the list\n    objects.next = {\n      // eslint-disable-line no-param-reassign\n      key: key,\n      next: objects.next,\n      value: value\n    };\n  }\n};\nvar listHas = function (objects, key) {\n  return !!listGetNode(objects, key);\n};\nmodule.exports = function getSideChannel() {\n  var $wm;\n  var $m;\n  var $o;\n  var channel = {\n    assert: function (key) {\n      if (!channel.has(key)) {\n        throw new $TypeError('Side channel does not contain ' + inspect(key));\n      }\n    },\n    get: function (key) {\n      // eslint-disable-line consistent-return\n      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n        if ($wm) {\n          return $weakMapGet($wm, key);\n        }\n      } else if ($Map) {\n        if ($m) {\n          return $mapGet($m, key);\n        }\n      } else {\n        if ($o) {\n          // eslint-disable-line no-lonely-if\n          return listGet($o, key);\n        }\n      }\n    },\n    has: function (key) {\n      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n        if ($wm) {\n          return $weakMapHas($wm, key);\n        }\n      } else if ($Map) {\n        if ($m) {\n          return $mapHas($m, key);\n        }\n      } else {\n        if ($o) {\n          // eslint-disable-line no-lonely-if\n          return listHas($o, key);\n        }\n      }\n      return false;\n    },\n    set: function (key, value) {\n      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n        if (!$wm) {\n          $wm = new $WeakMap();\n        }\n        $weakMapSet($wm, key, value);\n      } else if ($Map) {\n        if (!$m) {\n          $m = new $Map();\n        }\n        $mapSet($m, key, value);\n      } else {\n        if (!$o) {\n          /*\r\n           * Initialize the linked list as an empty node, so that we don't have\r\n           * to special-case handling of the first node: we can always refer to\r\n           * it as (previous node).next, instead of something like (list).head\r\n           */\n          $o = {\n            key: {},\n            next: null\n          };\n        }\n        listSet($o, key, value);\n      }\n    }\n  };\n  return channel;\n};","map":{"version":3,"names":["GetIntrinsic","require","callBound","inspect","$TypeError","$WeakMap","$Map","$weakMapGet","$weakMapSet","$weakMapHas","$mapGet","$mapSet","$mapHas","listGetNode","list","key","prev","curr","next","listGet","objects","node","value","listSet","listHas","module","exports","getSideChannel","$wm","$m","$o","channel","assert","has","get","set"],"sources":["C:/Users/tung0/OneDrive/Documents/typing-speed-app/node_modules/side-channel/index.js"],"sourcesContent":["'use strict';\r\n\r\nvar GetIntrinsic = require('get-intrinsic');\r\nvar callBound = require('call-bind/callBound');\r\nvar inspect = require('object-inspect');\r\n\r\nvar $TypeError = GetIntrinsic('%TypeError%');\r\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\r\nvar $Map = GetIntrinsic('%Map%', true);\r\n\r\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\r\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\r\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\r\nvar $mapGet = callBound('Map.prototype.get', true);\r\nvar $mapSet = callBound('Map.prototype.set', true);\r\nvar $mapHas = callBound('Map.prototype.has', true);\r\n\r\n/*\r\n * This function traverses the list returning the node corresponding to the\r\n * given key.\r\n *\r\n * That node is also moved to the head of the list, so that if it's accessed\r\n * again we don't need to traverse the whole list. By doing so, all the recently\r\n * used nodes can be accessed relatively quickly.\r\n */\r\nvar listGetNode = function (list, key) { // eslint-disable-line consistent-return\r\n\tfor (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {\r\n\t\tif (curr.key === key) {\r\n\t\t\tprev.next = curr.next;\r\n\t\t\tcurr.next = list.next;\r\n\t\t\tlist.next = curr; // eslint-disable-line no-param-reassign\r\n\t\t\treturn curr;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nvar listGet = function (objects, key) {\r\n\tvar node = listGetNode(objects, key);\r\n\treturn node && node.value;\r\n};\r\nvar listSet = function (objects, key, value) {\r\n\tvar node = listGetNode(objects, key);\r\n\tif (node) {\r\n\t\tnode.value = value;\r\n\t} else {\r\n\t\t// Prepend the new node to the beginning of the list\r\n\t\tobjects.next = { // eslint-disable-line no-param-reassign\r\n\t\t\tkey: key,\r\n\t\t\tnext: objects.next,\r\n\t\t\tvalue: value\r\n\t\t};\r\n\t}\r\n};\r\nvar listHas = function (objects, key) {\r\n\treturn !!listGetNode(objects, key);\r\n};\r\n\r\nmodule.exports = function getSideChannel() {\r\n\tvar $wm;\r\n\tvar $m;\r\n\tvar $o;\r\n\tvar channel = {\r\n\t\tassert: function (key) {\r\n\t\t\tif (!channel.has(key)) {\r\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\r\n\t\t\t}\r\n\t\t},\r\n\t\tget: function (key) { // eslint-disable-line consistent-return\r\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\r\n\t\t\t\tif ($wm) {\r\n\t\t\t\t\treturn $weakMapGet($wm, key);\r\n\t\t\t\t}\r\n\t\t\t} else if ($Map) {\r\n\t\t\t\tif ($m) {\r\n\t\t\t\t\treturn $mapGet($m, key);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\r\n\t\t\t\t\treturn listGet($o, key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\thas: function (key) {\r\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\r\n\t\t\t\tif ($wm) {\r\n\t\t\t\t\treturn $weakMapHas($wm, key);\r\n\t\t\t\t}\r\n\t\t\t} else if ($Map) {\r\n\t\t\t\tif ($m) {\r\n\t\t\t\t\treturn $mapHas($m, key);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\r\n\t\t\t\t\treturn listHas($o, key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\tset: function (key, value) {\r\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\r\n\t\t\t\tif (!$wm) {\r\n\t\t\t\t\t$wm = new $WeakMap();\r\n\t\t\t\t}\r\n\t\t\t\t$weakMapSet($wm, key, value);\r\n\t\t\t} else if ($Map) {\r\n\t\t\t\tif (!$m) {\r\n\t\t\t\t\t$m = new $Map();\r\n\t\t\t\t}\r\n\t\t\t\t$mapSet($m, key, value);\r\n\t\t\t} else {\r\n\t\t\t\tif (!$o) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * Initialize the linked list as an empty node, so that we don't have\r\n\t\t\t\t\t * to special-case handling of the first node: we can always refer to\r\n\t\t\t\t\t * it as (previous node).next, instead of something like (list).head\r\n\t\t\t\t\t */\r\n\t\t\t\t\t$o = { key: {}, next: null };\r\n\t\t\t\t}\r\n\t\t\t\tlistSet($o, key, value);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn channel;\r\n};\r\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,YAAY,GAAGC,OAAO,CAAC,eAAe,CAAC;AAC3C,IAAIC,SAAS,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AAC9C,IAAIE,OAAO,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AAEvC,IAAIG,UAAU,GAAGJ,YAAY,CAAC,aAAa,CAAC;AAC5C,IAAIK,QAAQ,GAAGL,YAAY,CAAC,WAAW,EAAE,IAAI,CAAC;AAC9C,IAAIM,IAAI,GAAGN,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC;AAEtC,IAAIO,WAAW,GAAGL,SAAS,CAAC,uBAAuB,EAAE,IAAI,CAAC;AAC1D,IAAIM,WAAW,GAAGN,SAAS,CAAC,uBAAuB,EAAE,IAAI,CAAC;AAC1D,IAAIO,WAAW,GAAGP,SAAS,CAAC,uBAAuB,EAAE,IAAI,CAAC;AAC1D,IAAIQ,OAAO,GAAGR,SAAS,CAAC,mBAAmB,EAAE,IAAI,CAAC;AAClD,IAAIS,OAAO,GAAGT,SAAS,CAAC,mBAAmB,EAAE,IAAI,CAAC;AAClD,IAAIU,OAAO,GAAGV,SAAS,CAAC,mBAAmB,EAAE,IAAI,CAAC;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIW,WAAW,GAAG,SAAAA,CAAUC,IAAI,EAAEC,GAAG,EAAE;EAAE;EACxC,KAAK,IAAIC,IAAI,GAAGF,IAAI,EAAEG,IAAI,EAAE,CAACA,IAAI,GAAGD,IAAI,CAACE,IAAI,MAAM,IAAI,EAAEF,IAAI,GAAGC,IAAI,EAAE;IACrE,IAAIA,IAAI,CAACF,GAAG,KAAKA,GAAG,EAAE;MACrBC,IAAI,CAACE,IAAI,GAAGD,IAAI,CAACC,IAAI;MACrBD,IAAI,CAACC,IAAI,GAAGJ,IAAI,CAACI,IAAI;MACrBJ,IAAI,CAACI,IAAI,GAAGD,IAAI,CAAC,CAAC;MAClB,OAAOA,IAAI;IACZ;EACD;AACD,CAAC;AAED,IAAIE,OAAO,GAAG,SAAAA,CAAUC,OAAO,EAAEL,GAAG,EAAE;EACrC,IAAIM,IAAI,GAAGR,WAAW,CAACO,OAAO,EAAEL,GAAG,CAAC;EACpC,OAAOM,IAAI,IAAIA,IAAI,CAACC,KAAK;AAC1B,CAAC;AACD,IAAIC,OAAO,GAAG,SAAAA,CAAUH,OAAO,EAAEL,GAAG,EAAEO,KAAK,EAAE;EAC5C,IAAID,IAAI,GAAGR,WAAW,CAACO,OAAO,EAAEL,GAAG,CAAC;EACpC,IAAIM,IAAI,EAAE;IACTA,IAAI,CAACC,KAAK,GAAGA,KAAK;EACnB,CAAC,MAAM;IACN;IACAF,OAAO,CAACF,IAAI,GAAG;MAAE;MAChBH,GAAG,EAAEA,GAAG;MACRG,IAAI,EAAEE,OAAO,CAACF,IAAI;MAClBI,KAAK,EAAEA;IACR,CAAC;EACF;AACD,CAAC;AACD,IAAIE,OAAO,GAAG,SAAAA,CAAUJ,OAAO,EAAEL,GAAG,EAAE;EACrC,OAAO,CAAC,CAACF,WAAW,CAACO,OAAO,EAAEL,GAAG,CAAC;AACnC,CAAC;AAEDU,MAAM,CAACC,OAAO,GAAG,SAASC,cAAcA,CAAA,EAAG;EAC1C,IAAIC,GAAG;EACP,IAAIC,EAAE;EACN,IAAIC,EAAE;EACN,IAAIC,OAAO,GAAG;IACbC,MAAM,EAAE,SAAAA,CAAUjB,GAAG,EAAE;MACtB,IAAI,CAACgB,OAAO,CAACE,GAAG,CAAClB,GAAG,CAAC,EAAE;QACtB,MAAM,IAAIX,UAAU,CAAC,gCAAgC,GAAGD,OAAO,CAACY,GAAG,CAAC,CAAC;MACtE;IACD,CAAC;IACDmB,GAAG,EAAE,SAAAA,CAAUnB,GAAG,EAAE;MAAE;MACrB,IAAIV,QAAQ,IAAIU,GAAG,KAAK,OAAOA,GAAG,KAAK,QAAQ,IAAI,OAAOA,GAAG,KAAK,UAAU,CAAC,EAAE;QAC9E,IAAIa,GAAG,EAAE;UACR,OAAOrB,WAAW,CAACqB,GAAG,EAAEb,GAAG,CAAC;QAC7B;MACD,CAAC,MAAM,IAAIT,IAAI,EAAE;QAChB,IAAIuB,EAAE,EAAE;UACP,OAAOnB,OAAO,CAACmB,EAAE,EAAEd,GAAG,CAAC;QACxB;MACD,CAAC,MAAM;QACN,IAAIe,EAAE,EAAE;UAAE;UACT,OAAOX,OAAO,CAACW,EAAE,EAAEf,GAAG,CAAC;QACxB;MACD;IACD,CAAC;IACDkB,GAAG,EAAE,SAAAA,CAAUlB,GAAG,EAAE;MACnB,IAAIV,QAAQ,IAAIU,GAAG,KAAK,OAAOA,GAAG,KAAK,QAAQ,IAAI,OAAOA,GAAG,KAAK,UAAU,CAAC,EAAE;QAC9E,IAAIa,GAAG,EAAE;UACR,OAAOnB,WAAW,CAACmB,GAAG,EAAEb,GAAG,CAAC;QAC7B;MACD,CAAC,MAAM,IAAIT,IAAI,EAAE;QAChB,IAAIuB,EAAE,EAAE;UACP,OAAOjB,OAAO,CAACiB,EAAE,EAAEd,GAAG,CAAC;QACxB;MACD,CAAC,MAAM;QACN,IAAIe,EAAE,EAAE;UAAE;UACT,OAAON,OAAO,CAACM,EAAE,EAAEf,GAAG,CAAC;QACxB;MACD;MACA,OAAO,KAAK;IACb,CAAC;IACDoB,GAAG,EAAE,SAAAA,CAAUpB,GAAG,EAAEO,KAAK,EAAE;MAC1B,IAAIjB,QAAQ,IAAIU,GAAG,KAAK,OAAOA,GAAG,KAAK,QAAQ,IAAI,OAAOA,GAAG,KAAK,UAAU,CAAC,EAAE;QAC9E,IAAI,CAACa,GAAG,EAAE;UACTA,GAAG,GAAG,IAAIvB,QAAQ,CAAC,CAAC;QACrB;QACAG,WAAW,CAACoB,GAAG,EAAEb,GAAG,EAAEO,KAAK,CAAC;MAC7B,CAAC,MAAM,IAAIhB,IAAI,EAAE;QAChB,IAAI,CAACuB,EAAE,EAAE;UACRA,EAAE,GAAG,IAAIvB,IAAI,CAAC,CAAC;QAChB;QACAK,OAAO,CAACkB,EAAE,EAAEd,GAAG,EAAEO,KAAK,CAAC;MACxB,CAAC,MAAM;QACN,IAAI,CAACQ,EAAE,EAAE;UACR;AACL;AACA;AACA;AACA;UACKA,EAAE,GAAG;YAAEf,GAAG,EAAE,CAAC,CAAC;YAAEG,IAAI,EAAE;UAAK,CAAC;QAC7B;QACAK,OAAO,CAACO,EAAE,EAAEf,GAAG,EAAEO,KAAK,CAAC;MACxB;IACD;EACD,CAAC;EACD,OAAOS,OAAO;AACf,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}