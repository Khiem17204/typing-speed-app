{"ast":null,"code":"const conversions = require('./conversions');\nconst route = require('./route');\nconst convert = {};\nconst models = Object.keys(conversions);\nfunction wrapRaw(fn) {\n  const wrappedFn = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const arg0 = args[0];\n    if (arg0 === undefined || arg0 === null) {\n      return arg0;\n    }\n    if (arg0.length > 1) {\n      args = arg0;\n    }\n    return fn(args);\n  };\n\n  // Preserve .conversion property if there is one\n  if ('conversion' in fn) {\n    wrappedFn.conversion = fn.conversion;\n  }\n  return wrappedFn;\n}\nfunction wrapRounded(fn) {\n  const wrappedFn = function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    const arg0 = args[0];\n    if (arg0 === undefined || arg0 === null) {\n      return arg0;\n    }\n    if (arg0.length > 1) {\n      args = arg0;\n    }\n    const result = fn(args);\n\n    // We're assuming the result is an array here.\n    // see notice in conversions.js; don't use box types\n    // in conversion functions.\n    if (typeof result === 'object') {\n      for (let len = result.length, i = 0; i < len; i++) {\n        result[i] = Math.round(result[i]);\n      }\n    }\n    return result;\n  };\n\n  // Preserve .conversion property if there is one\n  if ('conversion' in fn) {\n    wrappedFn.conversion = fn.conversion;\n  }\n  return wrappedFn;\n}\nmodels.forEach(fromModel => {\n  convert[fromModel] = {};\n  Object.defineProperty(convert[fromModel], 'channels', {\n    value: conversions[fromModel].channels\n  });\n  Object.defineProperty(convert[fromModel], 'labels', {\n    value: conversions[fromModel].labels\n  });\n  const routes = route(fromModel);\n  const routeModels = Object.keys(routes);\n  routeModels.forEach(toModel => {\n    const fn = routes[toModel];\n    convert[fromModel][toModel] = wrapRounded(fn);\n    convert[fromModel][toModel].raw = wrapRaw(fn);\n  });\n});\nmodule.exports = convert;","map":{"version":3,"names":["conversions","require","route","convert","models","Object","keys","wrapRaw","fn","wrappedFn","_len","arguments","length","args","Array","_key","arg0","undefined","conversion","wrapRounded","_len2","_key2","result","len","i","Math","round","forEach","fromModel","defineProperty","value","channels","labels","routes","routeModels","toModel","raw","module","exports"],"sources":["C:/Users/tung0/OneDrive/Documents/typing-speed-app/node_modules/@testing-library/jest-dom/node_modules/color-convert/index.js"],"sourcesContent":["const conversions = require('./conversions');\nconst route = require('./route');\n\nconst convert = {};\n\nconst models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\tconst result = fn(args);\n\n\t\t// We're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(fromModel => {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tconst routes = route(fromModel);\n\tconst routeModels = Object.keys(routes);\n\n\trouteModels.forEach(toModel => {\n\t\tconst fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}